/*
 * Copyright 2009-2019 Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dk.brics.tajs.preprocessing;

import dk.brics.tajs.options.Options;
import dk.brics.tajs.options.TAJSEnvironmentConfig;
import dk.brics.tajs.util.AnalysisException;
import dk.brics.tajs.util.PathAndURLUtils;
import org.apache.log4j.Logger;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Babel {

    private static final Logger log = Logger.getLogger(Babel.class);

    /**
     * Methods for singleton.
     */
    private Babel() {}

    private static Babel babel = null;

    public static Babel get() {
        if (babel == null)
            babel = new Babel();
        return babel;
    }

    private final String babelPlugins =
            Stream.of("arrow-functions", "block-scoping", "classes", "shorthand-properties", // "for-of" generates code we cannot handle
                      "template-literals", "parameters", "spread", "destructuring", "computed-properties")
            .map(name -> "@babel/plugin-transform-" + name).collect(Collectors.joining(","));

    private final Pattern successPattern = Pattern.compile("Successfully compiled (\\d+) files? with Babel\\.");

    private final Set<String> supportedFileExtensions = new HashSet<>(Arrays.asList(".es6", ".js", ".es", ".jsx", ".mjs", ""));

    /**
     * This method performs babel preprocessing on the files listed in the *files* parameter.
     * It replaces the main file of the analysis with the one generated by babel.
     * If soundness testing is enabled the *onlyIncludeForInstrumentation* options will be
     * updated to point to the files generated by babel.
     *
     * The method assumes that the main file is in the set of files given, or at least in
     * the subtree of the common ancestor of the files given.
     *
     * Additional options for babel can be specified in babel.config.js in extras/babel.
     *
     * @param commonAncestor The path to the common ancestor of all files in an application.
     *                       Files output by babel will be put in a directory structure similar to the one
     *                       found in commonAncestor in a subdirectory named "_babel".
     * @param files A set of files to be processed by babel. Other files found in the directory
     *              specified by *commonAncestor* will be copied as-is.
     */
    public void init(Path commonAncestor, Set<Path> files) {
        List<Path> args = Options.get().getArguments();
        Path testFile = args.get(args.size() - 1);
        Path babelRoot = commonAncestor.resolve("_babel");
        Path babelPath = TAJSEnvironmentConfig.get().getBabel();

        /* If we run babel with the project root as input directory, it will copy all files in it!
            TODO: Better detection of error condition */
        if (commonAncestor.endsWith("TAJS-private") || commonAncestor.endsWith("TAJS"))
            throw new IllegalArgumentException("Common ancestor of analysed files is the project root!");

        Set<Path> relativeFiles = files.stream()  // Babel does not handle json files so let us filter those out
                .filter(file -> !PathAndURLUtils.getFileExtension(file).equals(".json"))
                .map(file -> PathAndURLUtils.toRealPath(commonAncestor).relativize(file.toAbsolutePath()))
                .collect(Collectors.toSet());

        Set<String> fileExtensions = relativeFiles.stream().map(PathAndURLUtils::getFileExtension).collect(Collectors.toSet());
        fileExtensions.retainAll(supportedFileExtensions);

        ArrayList<String> cmd = new ArrayList<>(Arrays.asList(
                babelPath.toString(),
                "--root-mode", "upward",            // Find the nearest babel.config.js in the file-system
                "--extensions", String.join(",", fileExtensions),
                "--keep-file-extension",
                "--verbose",
                "--plugins", babelPlugins,          // Plugins used for transformations
                "--out-dir", babelRoot.toString(),  // Output directory
                "--delete-dir-on-start",
                "--copy-files",
                "--only",                           // Control which files to transform (must be absolute for babel to work correctly)
                relativeFiles.stream().map(file -> commonAncestor.resolve(file).toString()).collect(Collectors.joining(",")),
                commonAncestor.toString()           // Input directory
        ));

        /* For debugging
        System.err.println("commonAncestor: " + commonAncestor);
        relativeFiles.stream().sorted().forEach(System.err::println);
        System.err.println(cmd);
        System.exit(1);
        */

        try {
            // Run the babel command
            Process process = new ProcessBuilder(cmd).directory(babelPath.getParent().toFile()).start();
            String output, err;

            try (BufferedReader stdBr = new BufferedReader(new InputStreamReader(process.getInputStream()));
                BufferedReader errBr = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {

                output = stdBr.lines().collect(Collectors.joining("\n"));
                err = errBr.lines().collect(Collectors.joining("\n"));
                process.waitFor();
            }

            if (process.exitValue() != 0)
                throw new AnalysisException("Error occurred while running babel:\n" + err);

            Matcher m = successPattern.matcher(output);
            if (!m.find())
                log.warn("Babel might not have run successfully!\n" + output);
            else {
                int processedFiles = Integer.parseInt(m.group(1));
                if (processedFiles != relativeFiles.size())
                    throw new AnalysisException(String.format("Babel processed %d/%d files", processedFiles, relativeFiles.size()));
            }
        } catch (InterruptedException | IOException e) {
            throw new AnalysisException("Error occurred while running babel: " + e);
        }

        // Override soundness tester options with new files
        if (Options.get().getSoundnessTesterOptions().isGenerateOnlyIncludeAutomaticallyForHTMLFiles()
            || Options.get().getSoundnessTesterOptions().isGenerateOnlyIncludeAutomatically()) {

            Set<Path> babelFiles = relativeFiles.stream().map(babelRoot::resolve).collect(Collectors.toSet());
            Options.get().getSoundnessTesterOptions().setOnlyIncludesForInstrumentation(Optional.of(babelFiles));
            // rootDirFromMainFile can keep its value
        }

        // Fix the main file path
        Path babelTestFile = PathAndURLUtils.getRelativeToTAJS(
                babelRoot.resolve(PathAndURLUtils.toRealPath(commonAncestor).relativize(testFile.toAbsolutePath()))
        ).get();
        args.set(args.size() - 1, babelTestFile);
    }
}
